* Simple Geometry Generation for Rendering

Simple Geometry [SG] is an ansi-c99 single-header framework for generating simple geometry.
SG is able to generate vertices, indices, normals & texture coordinates for various rendering primitives.

Generate the vertex positions of a sphere:
#+begin_src c++
sg_cube_info info{};
info.width = 0.5f;
info.height = 0.5f;
info.depth = 0.5f;
	
unsigned int length;
sg_cube_vertices(&info, &length, nullptr, nullptr, nullptr);
sg_position* positions = (sg_position*)malloc(length * sizeof(sg_position));
sg_cube_vertices(&cube_info, &length, positions, nullptr, nullptr);

//Alternatively, in C++ the std::vector<> can be used for buffers
std::vector<sg_normal> normals(length);
sg_cube_vertices(&cube_info, &length, nullptr, normals.data(), nullptr);
#+end_src

Note that error detection and management is omitted in the above example.

** The Goal
   
SG's overall purpose is to provide simple rendering primitives, ready to use and integrate into rendering engines without being conserned about the chosen rendering API.
With this library, new programmers should be able to just drop in "simple_geometry.h" and get started with primitive rendering with minimal friction.
The library dreams of being like "stb_image.h", the centerpiese for image importing in rendering tutorials.

** Why c99

The chosen way of implementating the library allows for maximum portability, and thereby usability of differernt platforms, rendering api's etc.
SG has no external dependencies, and even allows disabling posix header dependencies as-well.

* How to Use: Generate an Indexed Unit Sphere 

SG is an ansi-c99 api, but designed to work well with C++ such as with the std::vector container.
Please note that error checking has been omited for clarity.

#+begin_src c++
SG_status status;

// Provide an information structure, and a length destination.
// @note because the output vertex pointers are all 'nullptr', we 
//       explicitly ask to retrieve the length of the needed buffer.
//       Remember to provide a valid geometry info struct, as this
//       *can* have an influence in the returned length.
sg_indexed_sphere_info sphere{};
sphere.radius = 0.5f;
sphere.slices = 8f;
sphere.stacks = 8f;

// Provide a destination length variable, it will be overridden with
// the minimum required count of vertices that will be returned.
// @note the returned length signifies the count of vertices,
//       not the required memory size.
unsigned int indices_length;
status = sg_indexed_sphere_indices(&sphere, &indices_length, nullptr);
// Check that the length is correctly returned.
// @note that alternatively, the function sg_success() can be used to
//       convert any status into a success/failure signifying boolean.
if (status != SG_OK_RETURNED_LEN)
    exit(1);

std::vector<SG_indice> indices(indices_length);
status = sg_indexed_sphere_indices(&sphere, &indices_length, indices.data());
if (status != SG_OK_RETURNED_BUFFER)
    exit(1);

// Provide a destination length variable, it will be overridden with
// the minimum required count of vertices that will be returned.
// @note the returned length signifies the count of vertices,
//       not the required memory size.
unsigned int vertices_length;
status = sg_indexed_sphere_vertices(&sphere, &vertices_length, nullptr, nullptr, nullptr);
if (status != SG_OK_RETURNED_LEN)
    exit(1);

// Prepare buffers for the vertice data that will be generated.
// This can be done for each of the possible outputs specified in the function
// declaration, such as vertex- positions, normals & UV-coordinates.
// @note the minimum memory size required is sizeof(buffer-element) * length
std::vector<sg_position> positions(length);
std::vector<sg_texcoord> uvs(length);

// Generate the geometry vertices.
// @note because the output data pointer points to valid memory,
//       the actual vertex data is generated and outputted to
//       the provided buffers.
// @note In this case we explicitly only generate the positions of the vertices,
//       if Normals / UV-coordinates are needed, seperate buffers should be prepared
//       and provided for those.
status = sg_cube_vertices(&sphere, &vertices_length, positions.data(), nullptr, uvs.data());
if (status != SG_OK_RETURNED_BUFFER)
    exit(1);
#+end_src

Now it is safe to work with, and use the returned buffers for whatever is wanted, such as rendering or even further modification.
Even though the generated geometry can be used as-is, it would commonly be ideal to re-structure the data into other vertex structures fitting the user's needs.

#+begin_src c++
struct sg_strided_blockcopy_info info;
info.src.ptr = src1;
info.src.block_size = 2;
info.src.stride = 2;
info.src.block_count = 4;
info.dst.stride = 2;

status = sg_strided_blockcopy(&source, dst);
#+end_src


* Maximum Portability Through Design
 
This philosophy shines through the API's design.
SG does not make any assumptions about the environment, available posix libraries or the specifics of how data should be procured or managed.
The API is designed in a rather classical style, inspired by other C API's such as Vulkan. 
This means that the library itself does not create, destroy or manage any allocations, instead
it is up to the caller to provide a memory area large enough to facilitate the returned data in the places where generated geometry is returned.
In order to make use of the geometry generation functions of this library, the user is required to call the function twice, providing the same info structure each time.

1. When the generator is called the first time, a pointer to a length variable is required, so that the generator can use the information structure to determine and return a size.
When doing this, a return status of SG_OK_RETURNED_LEN is returned by the function, signalling that using the length variable is okay. 
2. After a length is correctly returned by the generator, it is now required that the caller procure a buffer, that is at-least the size of of length, multiplied by the size of the returned buffer elements.

Examples of this can be seen throughout the library:

#+begin_src c++
SG_API_EXPORT
enum sg_status
sg_indexed_sphere_vertices(SG_IN  struct sg_indexed_sphere_info* info,
						   SG_OUT SG_size* length,
						   SG_OUT struct sg_position* positions,
						   SG_OUT struct sg_normal* normals,
						   SG_OUT struct sg_texcoord* texcoords)
#+end_src
Ensure to read the documentation for the individual signatures to understand how they are used.

** Transparency & Error Reporting

SG provides maximum transparency in what is happening.
All SG functions that has some kind of state associated with its usage, returns a status, except in the case where failing is simply not possible.
This gives the user maximum insight in the result of an operation, both upon success and failure states.

Functions that by definition cannot fail is considered the only exception to the above rule however:
#+begin_src c++
SG_API_EXPORT
struct sg_material
sg_material_gold(); 
#+end_src
In this case no error checking is needed and the result is directly returned.

A function that requires error management can be seen here:
#+begin_src c++
SG_API_EXPORT
enum SG_status
sg_indexed_cube_indices(SG_OUT SG_indice* dst,
						SG_OUT SG_size* dstlen);
#+end_src

In this case the retuned SG_status enum is encouraged to be checked.

*** Checking Errors

Checking for errors is essencially as simple as calling
#+begin_src c++
SG_API_EXPORT
SG_bool
sg_success(SG_IN const enum SG_status status); 
#+end_src
On the returned status code from any function that can fail.	
This is fine for most cases, but take note that a function can have different success
cases that can be relevant to check:

#+begin_src c++
unsigned int length;
enum SG_status status = sg_cube_positions(5, 5, 0.2f, nullptr, &length);
if (!sg_success(status)) {
    // Error handling
}
#+end_src
In this example we can intuitively see that the function returns success because
the length of the input buffer is returned.
We do however not check for this specific success case, and we might require other
success cases to be considered error cases for this specific call. 
Therefore it can be beneficial to instead check on the specific expected returned
status:
#+begin_src c++
if (status != SG_OK_RETURNED_LEN) {
    // Error handling
}
#+end_src

From this we can also be vocal about what was returned and use the stringification
function to convert all known status conditions into something printable:
#+begin_src c++
unsigned int length;
enum SG_status status = sg_cube_positions(5, 5, 0.2f, nullptr, &length);
if (status != SG_OK_RETURNED_LEN) {
    printf("SG error: %s\n", sg_status_string(status));
}
printf("SG success: %s\n", sg_status_string(status));
#+end_src

* Feature List

- [ ] Fully-Featured Tests:
  + [ ] Minimal Opengl Example

- [X] Utilities:
  + [X] Strided Block Copying for SOA Vertices Generation
  + [X] Flat Normal Calculation from Non-Indexed Vertices

- [ ] Geometry:
  + [X] Indexed Plane
  + [ ] Subdivided Plane (For Height Mapping)
  + [X] Indexed Cube
  + [X] Non-Indexed Cube
  + [ ] UV Sphere
  + [ ] UV Sphere
  + [ ] ICO Sphere
  + [ ] Cylinder
  + [ ] Cone
  + [ ] Capsule

- [ ] Simple Flat Materials:
  + [.] Ones found at: http://devernay.free.fr/cours/opengl/materials.html

- [ ] math.h Library Replacement:
  + [X] Allows Disabling
  + [ ] Contains alternative math operations such as square-root
