* Simple Geometry Generation for Rendering

Simple Geometry [SG] is an ansi-c99 single-header framework for generating simple geometry.
SG is able to generate vertices, indices, normals & texture coordinates for various rendering primitives.

Generate the vertex positions of a sphere:
#+begin_src c++
sg_cube_info info{};
info.width = 0.5f;
info.height = 0.5f;
info.depth = 0.5f;
	
unsigned int length;
sg_cube_vertices(&info, &length, nullptr, nullptr, nullptr);
sg_position* positions = (sg_position*)malloc(length * sizeof(sg_position));
sg_cube_vertices(&cube_info, &length, positions, nullptr, nullptr);

//Alternatively, in C++ the std::vector<> can be used for buffers
std::vector<sg_normal> normals(length);
sg_cube_vertices(&cube_info, &length, nullptr, normals.data(), nullptr);
#+end_src

Note that error detection and management is omitted in the above example.

** The Goal
   
SG's overall purpose is to provide simple rendering primitives, ready to use and integrate into rendering engines without being conserned about the chosen rendering API.
With this library, new programmers should be able to just drop in "simple_geometry.h" and get started with primitive rendering with minimal friction.
The library dreams of being like "stb_image.h", the centerpiese for image importing in rendering tutorials.

** Why c99

The chosen way of implementating the library allows for maximum portability, and thereby usability of differernt platforms, rendering api's etc.
SG has no external dependencies, and even allows disabling posix header dependencies as-well.

* How to Use: Generate an Indexed Unit Sphere 

SG is an ansi-c99 api, but designed to work well with C++ such as with the std::vector container.
Please note that error checking has been omited for clarity.

#+begin_src c++
SG_status status;

// Provide an information structure, and a length destination.
// @note because the output vertex pointers are all 'nullptr', we 
//       explicitly ask to retrieve the length of the needed buffer.
//       Remember to provide a valid geometry info struct, as this
//       *can* have an influence in the returned length.
sg_indexed_sphere_info sphere{};
sphere.radius = 0.5f;
sphere.slices = 8f;
sphere.stacks = 8f;

// Provide a destination length variable, it will be overridden with
// the minimum required count of vertices that will be returned.
// @note the returned length signifies the count of vertices,
//       not the required memory size.
unsigned int indices_length;
status = sg_indexed_sphere_indices(&sphere, &indices_length, nullptr);
// Check that the length is correctly returned.
// @note that alternatively, the function sg_success() can be used to
//       convert any status into a success/failure signifying boolean.
if (status != SG_OK_RETURNED_LEN)
    exit(1);

std::vector<SG_indice> indices(indices_length);
status = sg_indexed_sphere_indices(&sphere, &indices_length, indices.data());
if (status != SG_OK_RETURNED_BUFFER)
    exit(1);

// Provide a destination length variable, it will be overridden with
// the minimum required count of vertices that will be returned.
// @note the returned length signifies the count of vertices,
//       not the required memory size.
unsigned int vertices_length;
status = sg_indexed_sphere_vertices(&sphere, &vertices_length, nullptr, nullptr, nullptr);
if (status != SG_OK_RETURNED_LEN)
    exit(1);

// Prepare buffers for the vertice data that will be generated.
// This can be done for each of the possible outputs specified in the function
// declaration, such as vertex- positions, normals & UV-coordinates.
// @note the minimum memory size required is sizeof(buffer-element) * length
std::vector<sg_position> positions(length);
std::vector<sg_texcoord> uvs(length);

// Generate the geometry vertices.
// @note because the output data pointer points to valid memory,
//       the actual vertex data is generated and outputted to
//       the provided buffers.
// @note In this case we explicitly only generate the positions of the vertices,
//       if Normals / UV-coordinates are needed, seperate buffers should be prepared
//       and provided for those.
status = sg_cube_vertices(&sphere, &vertices_length, positions.data(), nullptr, uvs.data());
if (status != SG_OK_RETURNED_BUFFER)
    exit(1);
#+end_src

Now it is safe to work with, and use the returned buffers for whatever is wanted, such as rendering or even further modification.
The returned vertex data from this library is returned as individual buffers, fitting for usage denoted as Structure-Of-Arrays (SOA).
This layout is identified by the individual vertex elements being located in their own array structures, meaning that individual vertex sub-type is contained in its own buffer.
This layout form is chosen as the output as it allows for easier re-formatting should the user require another form of vertex layout.

Even though the generated geometry can be used in its SOA layout, it would commonly be required to re-structure the data into other vertex structures fitting the user's needs.
Consider the definition of a vertex, used for a custom renderer:
#+begin_src c++
struct vertex {
   struct {
      float x;
      float y;
      float z;
   } pos;
   struct {
      float u;
      float v;
   } tex;
};
#+end_src

This structure exibits a layout called Array-Of-Structures (AOS), identified by the individual vertex elements being located alongside each-other in an single array structure.
Should the user require that the layout of the vertices , such as This can easily be done:
this is done with the intent that the user should stitch together the data in any fitting ordering required, such as the vertex structure defined above.
To fit the data to the example vertex structure, one can use the strided blockcopy utility:
#+begin_src c++
// Given the generated buffers, modeling the SOA pattern:
std::vector<sg_position> positions(length);
std::vector<sg_texcoord> uvs(length);

// Create a buffer for the vertices modeling a AOS pattern.
// @note same length as the individual buffers is required.
std::vector<vertex> vertices(length);

// Create and specify the contents of a blockcopy source information structure 
// so that it fits the layout of the returned vertex buffer:
struct sg_strided_blockcopy_source_info positions_copy;
positions_copyptr = positions.data();
positions_copyblock_size = sizeof(positions[0]);
positions_copystride = sizeof(positions[0]);
positions_copyblock_count = positions.size();

// Do the strided blockcopy for the positions.
// @note that the stride of the destination buffer is the
//       size of the entire vertex structure, and the
//       destination pointer is provided seperately,
//       as to encourage re-use of the source_info structure
//       for multiple copying operations.
status = sg_strided_blockcopy(&positions_copy,
                              sizeof(vertex),
                              vertices.data());

struct sg_strided_blockcopy_source_info uvs_copy;
uvs_copyptr = uvs.data();
uvs_copyblock_size = sizeof(uvs[0]);
uvs_copystride = sizeof(uvs[0]);
uvs_copyblock_count = uvs.size();

// Do the strided blockcopy for the texture coordinates.
// @note that the stride of the destination buffer is the
//       same as the copy operation earlier, but this time
//       the destination pointer is slided forward to correctly
//       point to the beginning of the data to copy.
//       In this case we increment by the size of the position,
//       as we want to copy to the tex structure.
status = sg_strided_blockcopy(&uvs_copy,
                              sizeof(vertex),
                              vertices.data() + sizeof(vertex.pos));
#+end_src

Following this process it is possible to stitch together vertex data that contains sets of vertex datas.

* Feature List

- [ ] Fully-Featured Tests:
  + [ ] Minimal Opengl Example

- [X] Utilities:
  + [X] Strided Block Copying for SOA Vertices Generation
  + [X] Flat Normal Calculation from Non-Indexed Vertices

- [ ] Geometry:
  + [X] Indexed Plane
  + [ ] Subdivided Plane (For Height Mapping)
  + [X] Indexed Cube
  + [X] Non-Indexed Cube
  + [ ] UV Sphere
  + [ ] UV Sphere
  + [ ] ICO Sphere
  + [ ] Cylinder
  + [ ] Cone
  + [ ] Capsule

- [ ] Simple Flat Materials:
  + [.] Ones found at: http://devernay.free.fr/cours/opengl/materials.html

- [ ] math.h Library Replacement:
  + [X] Allows Disabling
  + [ ] Contains alternative math operations such as square-root
